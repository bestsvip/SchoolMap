<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>基于真实GPS的战争迷雾</title>
    <style>
        body {
            background-color: #ffffff;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            max-height: 100vh;
            margin: 0;
            padding: 0px;
        }

        .container {
            text-align: center;
        }

        #mapCanvas {
            background-color: #ffffff;
            /* border: 2px solid #cccccc; */
            display: block;
            /* margin: 20px auto; */
            touch-action: none;
            /* 禁用默认触摸行为 */
        }

        .location-btn {
            width: 80px;
            height: 30px;
            background-color: #007bff;
            color: #ffffff;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            margin: 10px 0;
        }

        .location-btn:hover {
            background-color: #0056b3;
        }

        .hint-text {
            color: #333333;
            font-size: 16px;
            margin: 10px 0;
        }

        .status-text {
            color: #666666;
            font-size: 14px;
            margin: 10px 0;
        }

        .coordinates-display {
            color: #007bff;
            font-size: 14px;
            margin: 10px 0;
            min-height: 20px;
        }

        .instructions {
            color: #888888;
            font-size: 14px;
            margin-top: 10px;
            max-width: 600px;
        }

        .status-text {
            display: none;
        }
    </style>
    <style>
        /* 底部栏样式 */
        .bottom-panel {
            position: fixed;
            left: 20px;
            bottom: 20px;
            right: 20px;
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }

        .panel-content {
            padding: 15px;
            background-color: white;
            display: flex;
            flex-wrap: wrap;
            display: grid;
            gap: 10px;
            /* 列间距 */
            overflow-x: auto;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;

        }

        .panel-content::-webkit-scrollbar {
            display: none;
        }

        .card {
            flex: 0 0 auto;
            width: 80%;
            max-width: 300px;
            margin-right: 15px;
            background: #f9f9f9;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .card:last-child {
            margin-right: 0;
        }

        .card {
            width: 200px;
            height: 80px;
            background: linear-gradient(135deg, #4a90e2, #2c7bb6);
            border-radius: 15px;
            padding: 15px;
            color: white;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
            scroll-behavior: smooth;
            /* display: flex; */
            /* flex-direction: column; */
            /* justify-content: space-between; */
        }

        .top-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }

        .location {
            font-size: 20px;
            font-weight: bold;
        }

        .status {
            background-color: rgba(255, 255, 255, 0.9);
            color: #4a90e2;
            border-radius: 15px;
            padding: 5px 12px;
            font-size: 14px;
            font-weight: bold;
            z-index: 10;
        }

        .statusChecked {
            /* background-color: rgba(255, 255, 255, 0.9); */
            color: #fff;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.9);
            padding: 5px 12px;
            font-size: 14px;
            font-weight: bold;
            z-index: 10;
        }

        .title {
            font-size: 18px;
            margin-top: 10px;
            font-weight: normal;
            position: relative;
            z-index: 10;
        }

        .detail-btn {
            position: absolute;
            bottom: 15px;
            right: 15px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            cursor: pointer;
            text-decoration: underline;
        }

        .detail-btn:hover {
            color: white;
        }

        .GateIcon {
            transform: scale(0.5);
            margin-top: -70px;
            transform-origin: right top;
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- <p class="hint-text">允许位置访问以显示您的位置</p>
        <p class="status-text" id="statusText">正在获取位置...</p>
        <canvas id="mapCanvas" width="1975" height="2027"></canvas>
        <canvas id="mapCanvas" width="1600" height="1800"></canvas>
        <p class="coordinates-display" id="coordinatesDisplay"></p>
        <button class="location-btn" id="locateBtn">重新定位</button>
        <button class="location-btn" id="clearFogBtn">清除迷雾</button>
        <p class="instructions">移动时会逐渐揭示地图。实际使用时，您的GPS位置更新会揭示地图。</p> -->
        <p class="status-text" id="statusText" style="display: none;">正在获取位置...</p>
        <canvas id="mapCanvas" width="800" height="900"></canvas>
    </div>

    <!-- 底部栏 -->
    <div class="bottom-panel" id="bottomPanel">
        <div class="panel-content" id="panel-content">
            <!-- <div class="card">
                <p>第一行内容：这是底部栏的第一行信息，您可以在这里显示相关的详细内容。</p>
            </div> -->
        </div>
    </div>
    <script>
        const svg = `<svg version="1.1" id="svg1" width="254.23466" height="223.95734" viewBox="0 0 254.23466 223.95734">
            <g>
                <path id="path1" d="m 0,0 c 0,15.611 0.032,31.223 -0.057,46.833 -0.008,1.349 1.305,3.82 -2.009,3.643 -2.421,-0.129 -3.766,-0.635 -3.758,-3.646 0.077,-31.221 -0.004,-62.442 -0.049,-93.663 -0.003,-1.915 -0.289,-3.617 2.752,-3.592 2.874,0.023 3.171,1.232 3.16,3.591 C -0.038,-31.223 -0.001,-15.611 0,0 m -34.846,65.662 c 0,1.622 0.002,3.244 -0.001,4.866 -0.008,4.62 0.001,4.585 -4.406,3.374 -26.124,-7.176 -50.409,-18.336 -73.264,-32.894 -5.055,-3.22 -6.904,-6.588 -6.322,-12.285 0.315,-3.084 0.672,-3.632 3.549,-2.107 22.955,12.166 47.115,21.277 72.143,28.16 8.32,2.288 8.301,2.36 8.301,10.886 m 13.439,-70.293 c 0,-2.496 0,-4.993 0,-7.489 0,-13.607 -0.019,-27.213 0.035,-40.819 0.005,-1.185 -0.774,-3.169 1.417,-3.216 6.113,-0.132 12.231,-0.054 18.347,-0.043 0.833,0.002 1.437,0.356 1.465,1.298 0.028,0.966 -0.597,1.292 -1.419,1.355 -0.745,0.057 -1.495,0.066 -2.243,0.078 -4.997,0.082 -5.012,0.081 -5.005,5.144 0.04,29.458 0.091,58.916 0.13,88.375 0.013,9.642 0.032,9.511 -9.35,7.397 -2.801,-0.632 -3.456,-1.84 -3.435,-4.52 0.118,-15.852 0.058,-31.706 0.058,-47.56 m -100.349,-21.974 c 0.014,0 0.027,0 0.041,0 0,10.358 0.007,20.716 -0.004,31.074 -0.005,3.881 -0.004,3.842 -3.5,1.882 -7.623,-4.273 -14.798,-9.228 -21.962,-14.209 -1.517,-1.055 -2.05,-2.235 -2.044,-4.031 0.051,-16.099 0.08,-32.199 -0.021,-48.297 -0.017,-2.643 0.859,-3.401 3.442,-3.388 17.097,0.085 34.195,0.018 51.292,0.048 1.101,0.002 2.885,-0.622 2.951,1.286 0.078,2.274 -1.911,1.482 -3.081,1.492 -7.862,0.064 -15.727,0.14 -23.586,-0.036 -2.718,-0.061 -3.652,0.58 -3.6,3.48 0.185,10.23 0.072,20.465 0.072,30.699 M -9.002,80.098 c 0,4.497 0.008,8.994 -0.002,13.49 -0.01,4.4 -0.035,4.472 -4.335,3.415 -40.811,-10.026 -77.875,-28.176 -112.405,-51.834 -1.547,-1.06 -2.027,-2.271 -1.999,-4.051 0.085,-5.37 -0.019,-10.742 0.063,-16.112 0.022,-1.415 -0.813,-3.56 0.614,-4.096 1.587,-0.594 3.094,1.182 4.57,2.048 1.076,0.632 0.761,1.753 0.769,2.712 0.028,3.373 0.111,6.749 -0.026,10.116 -0.08,1.959 0.555,3.134 2.242,4.251 7.693,5.098 15.539,9.928 23.618,14.388 19.187,10.592 39.486,18.312 60.68,23.811 2.809,0.729 3.442,0.143 3.354,-2.598 -0.165,-5.116 -0.002,-10.242 -0.068,-15.362 -0.023,-1.818 0.43,-2.372 2.376,-1.909 6.05,1.438 12.141,2.713 18.234,3.957 1.861,0.38 2.362,1.409 2.336,3.161 -0.072,4.87 -0.025,9.742 -0.021,14.613 m -82.359,-97.815 c 0,12.243 -0.007,24.486 0.008,36.729 0.002,2.01 -0.025,3.596 -2.853,2.27 -7.329,-3.438 -14.723,-6.739 -22.113,-10.044 -1.657,-0.742 -2.44,-1.736 -2.438,-3.687 0.027,-20.737 -0.009,-41.475 -0.117,-62.213 -0.012,-2.29 0.734,-3.049 3.008,-3.016 6.995,0.105 13.996,0.166 20.986,-0.039 2.886,-0.085 3.598,0.932 3.572,3.646 -0.116,12.117 -0.05,24.235 -0.053,36.354 M 35.585,7.86 c 0,16.87 0,33.739 0,50.608 0,7.533 10e-4,7.532 -7.628,6.935 -0.498,-0.039 -1,-0.042 -1.496,-0.095 C 16.405,64.25 6.417,62.734 -3.505,60.79 c -4.029,-0.79 -2,-4.003 -2.11,-6.106 -0.123,-2.373 1.932,-1.248 3.071,-1.084 5.478,0.787 5.477,0.827 5.477,-4.843 0.002,-31.615 0.055,-63.23 -0.076,-94.843 -0.014,-3.472 0.977,-4.42 4.389,-4.314 7.989,0.249 15.996,0.231 23.987,0.002 3.334,-0.095 4.475,0.714 4.438,4.277 -0.187,17.992 -0.086,35.987 -0.086,53.981 M -34.846,-2.141 c 0,16.994 10e-4,33.989 -0.001,50.983 -10e-4,5.041 0,5.016 -4.893,3.679 -26.18,-7.156 -51.421,-16.706 -75.526,-29.249 -2.807,-1.461 -3.579,-3.138 -3.539,-6.082 0.042,-3.103 0.867,-3.209 3.429,-2.02 7.45,3.46 15.011,6.681 22.541,9.966 4.323,1.886 4.341,1.861 4.341,-3.048 0.003,-25.242 0.045,-50.483 -0.055,-75.724 -0.011,-2.972 0.628,-4.131 3.892,-4.096 15.368,0.163 30.739,0.145 46.108,-0.008 3.054,-0.031 3.777,0.988 3.758,3.867 -0.113,17.243 -0.056,34.488 -0.055,51.732 M -122.06,19.11 c -2.507,-0.556 -4.409,-2.251 -6.582,-3.386 -1.432,-0.748 -2.009,-0.482 -2.004,1.197 0.03,8.996 0.046,17.993 -0.017,26.99 -0.01,1.5 0.77,2.194 1.848,2.94 25.009,17.312 51.534,31.738 80.073,42.394 12.486,4.662 25.134,8.726 38.165,11.566 4.328,0.943 4.505,0.867 4.513,-3.451 0.018,-10.122 0.101,-20.244 -0.049,-30.363 -0.044,-3.021 0.872,-3.529 3.708,-2.942 12.591,2.602 25.338,4.131 38.148,5.227 2.288,0.196 2.765,-0.416 2.762,-2.528 -0.046,-39.11 -0.053,-78.221 0.011,-117.332 0.004,-2.47 -1.074,-2.898 -3.161,-2.887 -9.496,0.052 -18.994,-0.056 -28.489,0.048 -2.688,0.029 -4.411,-0.415 -3.97,-3.633 0.263,-1.921 -0.984,-2.215 -2.567,-2.208 -7.372,0.035 -14.746,0.11 -22.115,-0.039 -2.772,-0.056 -2.571,1.557 -2.569,3.374 0.016,15.244 0.008,30.489 0.008,45.733 0,18.493 0.076,36.987 -0.076,55.479 -0.025,2.984 0.975,4.293 3.761,4.765 3.068,0.52 6.085,1.359 9.159,1.834 4.193,0.647 2.929,3.835 2.663,6.097 -0.321,2.742 -2.502,1.131 -3.841,0.86 -5.257,-1.063 -10.456,-2.431 -15.733,-3.365 -2.927,-0.517 -3.658,-1.83 -3.647,-4.717 0.134,-35.61 0.065,-71.222 0.245,-106.832 0.019,-3.734 -0.82,-4.783 -4.66,-4.727 -16.116,0.235 -32.237,0.036 -48.355,0.144 -2.682,0.018 -4.061,-0.578 -3.68,-3.485 0.26,-1.978 -0.742,-2.52 -2.633,-2.516 -19.368,0.048 -38.736,0.046 -58.103,-0.017 -2.02,-0.007 -2.921,0.491 -2.914,2.689 0.058,18.118 0.053,36.236 0.001,54.354 -0.005,1.774 0.906,2.67 2.185,3.59 7.6,5.468 15.392,10.642 23.466,15.384 5.343,3.139 5.356,3.118 4.449,9.763" style="fill:#1d2c71;fill-opacity:1;fill-rule:nonzero;stroke:none" transform="matrix(1.3333333,0,0,-1.3333333,202.88107,135.06347)" clip-path="url(#clipPath2)" />
            </g>
        </svg>`

        function setGrid(rows, columns, Building) {
            const container = document.getElementById('panel-content');
            container.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
            container.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;

            // 清空容器内容
            container.innerHTML = '';

            // 动态生成网格项
            for (let i = 1; i <= rows * columns; i++) {
                const item = document.createElement('div');
                if (Building[i - 1].status) {
                    item.innerHTML = `<div class="card">
                    <div class="top-section">
                        <div class="location">${Building[i - 1].location}</div>
                        <div class="statusChecked">已打卡</div>
                    </div >
                    <div class="title">${Building[i - 1].title}</div>
                    <!--<div class="detail-btn">查看详情</div>-->
                    <div class="GateIcon">
                        ${svg}
                    </div>
                    </div > `;
                } else {
                    item.innerHTML = `<div class="card">
                    <div class="top-section">
                        <div class="location">${Building[i - 1].location}</div>
                        <div class="status">未打卡</div>
                    </div>
                    <div class="title">${Building[i - 1].title}</div>
                    <!--< div class="detail-btn"> 查看详情</div> -->
                    <div class="GateIcon">
                        ${svg}
                    </div>
                    </div >`;

                }
                container.appendChild(item);
            }
        }
        // 修改: 添加id字段用于匹配hash值
        Buildings = [
            { id: 'jiaoyilou', location: '教学楼', status: 0, title: '教一' },
            { id: 'jiaoerA', location: '教学楼', status: 0, title: '教二A' },
            { id: 'jiaoerB', location: '教学楼', status: 0, title: '教二B' },
            { id: 'shishangxueyuan', location: '学院楼', status: 0, title: '时尚设计学院' },
            { id: 'gongchengxueyuan', location: '学院楼', status: 0, title: '机械工程学院' },
            { id: 'wenxueyuan', location: '学院楼', status: 0, title: '人文与艺术学院' },
        ]
        // 初始化为两行两列
        setGrid(2, Math.round(Buildings.length / 2), Buildings);
    </script>
    <script>
        // 战争迷雾类
        class WarFogMap {
            constructor(canvasId, options = {}) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');

                // 设置默认选项
                this.options = {
                    userColor: options.userColor || 'red',
                    userStrokeColor: options.userStrokeColor || 'white',
                    fogColor: options.fogColor || 'rgba(0, 0, 0, 0.8)',
                    revealRadius: options.revealRadius || 30,
                    ...options
                };

                // 创建遮罩画布
                this.maskCanvas = document.createElement('canvas');
                this.maskCanvas.width = this.canvas.width;
                this.maskCanvas.height = this.canvas.height;
                this.maskCtx = this.maskCanvas.getContext('2d');

                // 用户位置
                this.userX = this.canvas.width / 2;
                this.userY = this.canvas.height / 2;

                // GPS边界坐标
                this.gpsBounds = {
                    topLeft: { lng: 120.725840, lat: 30.749314 },
                    topRight: { lng: 120.733207, lat: 30.749314 },
                    bottomLeft: { lng: 120.725840, lat: 30.741963 },
                    bottomRight: { lng: 120.733207, lat: 30.741963 }
                };

                // 缩放和平移相关属性
                this.scale = 1;
                this.translateX = 0;
                this.translateY = 0;
                this.isDragging = false;
                this.lastX = 0;
                this.lastY = 0;
                this.lastTouches = [];

                // 初始化
                this.init();

                // 加载背景图片
                this.backgroundImage = new Image();
                this.backgroundImage.src = 'https://youke1.picui.cn/s1/2025/11/03/6908506fcab3c.jpg';
                this.backgroundImage.onload = () => {
                    this.backgroundLoaded = true;
                };

                // 绑定触摸事件
                this.bindTouchEvents();
            }

            // 初始化迷雾
            init() {
                this.resetFog();
                this.updateDisplay();
            }

            // 重置迷雾为完全覆盖状态
            resetFog() {
                this.maskCtx.fillStyle = 'black';
                this.maskCtx.fillRect(0, 0, this.maskCanvas.width, this.maskCanvas.height);
            }

            // 揭示指定区域（清除迷雾）
            revealArea(x, y, radius = this.options.revealRadius) {
                this.maskCtx.globalCompositeOperation = 'destination-out';
                this.maskCtx.beginPath();
                this.maskCtx.arc(x, y, radius, 0, Math.PI * 2);
                this.maskCtx.fill();
                this.maskCtx.globalCompositeOperation = 'source-over';
            }

            // 设置用户位置
            setUserPosition(x, y) {
                this.userX = x;
                this.userY = y;
                this.revealArea(x, y);
            }

            // 绘制用户位置
            drawUserPosition() {
                this.ctx.beginPath();
                this.ctx.arc(this.userX, this.userY, 5, 0, Math.PI * 2);
                this.ctx.fillStyle = this.options.userColor;
                this.ctx.fill();
                this.ctx.strokeStyle = this.options.userStrokeColor;
                this.ctx.lineWidth = 1;
                this.ctx.stroke();
            }

            // 更新显示
            updateDisplay() {
                // 清除画布
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // 保存当前上下文状态
                this.ctx.save();

                // 应用缩放和平移变换
                this.ctx.translate(this.translateX, this.translateY);
                this.ctx.scale(this.scale, this.scale);

                // 绘制背景图片
                if (this.backgroundLoaded && this.backgroundImage) {
                    // 修改: 使用drawImage的五参数版本，保持图片比例正确
                    const imgAspect = this.backgroundImage.width / this.backgroundImage.height;
                    const canvasAspect = this.canvas.width / this.canvas.height;

                    let renderWidth, renderHeight, offsetX = 0, offsetY = 0;

                    if (imgAspect > canvasAspect) {
                        // 图片更宽，以高度为准
                        renderHeight = this.canvas.height;
                        renderWidth = this.backgroundImage.width * (renderHeight / this.backgroundImage.height);
                        offsetX = (this.canvas.width - renderWidth) / 2;
                    } else {
                        // 图片更高，以宽度为准
                        renderWidth = this.canvas.width;
                        renderHeight = this.backgroundImage.height * (renderWidth / this.backgroundImage.width);
                        offsetY = (this.canvas.height - renderHeight) / 2;
                    }

                    this.ctx.drawImage(this.backgroundImage, offsetX, offsetY, renderWidth, renderHeight);
                } else {
                    // 如果图片未加载完成，先用白色填充
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                }

                // 绘制迷雾遮罩
                this.ctx.drawImage(this.maskCanvas, 0, 0);

                // 绘制用户位置
                this.drawUserPosition();

                // 恢复上下文状态
                this.ctx.restore();
            }

            // 获取用户位置
            getUserPosition() {
                return { x: this.userX, y: this.userY };
            }

            // 将GPS坐标转换为画布坐标
            gpsToCanvas(gpsLat, gpsLng) {
                const bounds = this.gpsBounds;

                // 计算经度比例 (x轴)
                const lngRatio = (gpsLng - bounds.topLeft.lng) /
                    (bounds.topRight.lng - bounds.topLeft.lng);

                // 计算纬度比例 (y轴) - 注意纬度是从上到下递减的
                const latRatio = (bounds.topLeft.lat - gpsLat) /
                    (bounds.topLeft.lat - bounds.bottomLeft.lat);

                // 转换为画布坐标
                const x = lngRatio * this.canvas.width;
                const y = latRatio * this.canvas.height;

                return { x, y };
            }

            // 将画布坐标转换为GPS坐标
            canvasToGps(x, y) {
                const bounds = this.gpsBounds;

                // 计算画布上的比例
                const lngRatio = x / this.canvas.width;
                const latRatio = y / this.canvas.height;

                // 转换为GPS坐标
                const lng = bounds.topLeft.lng + lngRatio * (bounds.topRight.lng - bounds.topLeft.lng);
                const lat = bounds.topLeft.lat - latRatio * (bounds.topLeft.lat - bounds.bottomLeft.lat);

                return { lat, lng };
            }

            // 新增清除迷雾的方法
            clearFog() {
                // 修改: 使用正确比例绘制背景图片
                if (this.backgroundLoaded && this.backgroundImage) {
                    const imgAspect = this.backgroundImage.width / this.backgroundImage.height;
                    const canvasAspect = this.canvas.width / this.canvas.height;

                    let renderWidth, renderHeight, offsetX = 0, offsetY = 0;

                    if (imgAspect > canvasAspect) {
                        renderHeight = this.canvas.height;
                        renderWidth = this.backgroundImage.width * (renderHeight / this.backgroundImage.height);
                        offsetX = (this.canvas.width - renderWidth) / 2;
                    } else {
                        renderWidth = this.canvas.width;
                        renderHeight = this.backgroundImage.height * (renderWidth / this.backgroundImage.width);
                        offsetY = (this.canvas.height - renderHeight) / 2;
                    }

                    this.ctx.drawImage(this.backgroundImage, offsetX, offsetY, renderWidth, renderHeight);
                }
            }

            // 新增方法：将用户位置居中显示
            centerOnUser() {
                // 计算需要的平移量，使得用户位置位于画布中心
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;

                // 更新translate值使得userX, userY位于画布中心
                this.translateX = centerX - this.userX * this.scale;
                this.translateY = centerY - this.userY * this.scale;
                this.updateDisplay();
            }

            // 绑定触摸事件
            bindTouchEvents() {
                // 鼠标事件
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('mouseleave', (e) => this.handleMouseUp(e));

                // 触摸事件
                this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
                this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
                this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));
                this.canvas.addEventListener('touchcancel', (e) => this.handleTouchEnd(e));

                // 滚轮事件（用于缩放）
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
            }

            // 鼠标按下事件
            handleMouseDown(e) {
                this.isDragging = true;
                this.lastX = e.clientX;
                this.lastY = e.clientY;
                this.canvas.style.cursor = 'grabbing';
            }

            // 鼠标移动事件
            handleMouseMove(e) {
                if (this.isDragging) {
                    const deltaX = e.clientX - this.lastX;
                    const deltaY = e.clientY - this.lastY;

                    this.translateX += deltaX;
                    this.translateY += deltaY;

                    this.lastX = e.clientX;
                    this.lastY = e.clientY;

                    this.updateDisplay();
                }
            }

            // 鼠标释放事件
            handleMouseUp(e) {
                this.isDragging = false;
                this.canvas.style.cursor = 'default';
            }

            // 触摸开始事件
            handleTouchStart(e) {
                e.preventDefault();
                this.lastTouches = Array.from(e.touches);

                if (e.touches.length === 1) {
                    this.lastX = e.touches[0].clientX;
                    this.lastY = e.touches[0].clientY;
                }
            }

            // 触摸移动事件
            handleTouchMove(e) {
                e.preventDefault();

                if (e.touches.length === 1) {
                    // 单指拖动
                    const deltaX = e.touches[0].clientX - this.lastX;
                    const deltaY = e.touches[0].clientY - this.lastY;

                    this.translateX += deltaX;
                    this.translateY += deltaY;

                    this.lastX = e.touches[0].clientX;
                    this.lastY = e.touches[0].clientY;

                    this.updateDisplay();
                } else if (e.touches.length === 2) {
                    // 双指缩放
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];

                    // 计算当前双指距离
                    const currentDistance = Math.sqrt(
                        Math.pow(touch2.clientX - touch1.clientX, 2) +
                        Math.pow(touch2.clientY - touch1.clientY, 2)
                    );

                    // 计算上一次双指距离
                    const lastTouch1 = this.lastTouches[0];
                    const lastTouch2 = this.lastTouches[1];
                    const lastDistance = Math.sqrt(
                        Math.pow(lastTouch2.clientX - lastTouch1.clientX, 2) +
                        Math.pow(lastTouch2.clientY - lastTouch1.clientY, 2)
                    );

                    // 计算缩放比例
                    if (lastDistance > 0) {
                        const scaleChange = currentDistance / lastDistance;
                        const newScale = this.scale * scaleChange;

                        // 限制缩放范围
                        if (newScale > 0.5 && newScale < 5) {
                            this.scale = newScale;

                            // 计算中心点以实现围绕中心缩放
                            const centerX = (touch1.clientX + touch2.clientX) / 2;
                            const centerY = (touch1.clientY + touch2.clientY) / 2;

                            // 调整平移以实现围绕中心点缩放
                            this.translateX = centerX - (centerX - this.translateX) * scaleChange;
                            this.translateY = centerY - (centerY - this.translateY) * scaleChange;

                            this.updateDisplay();
                        }
                    }

                    this.lastTouches = Array.from(e.touches);
                }
            }

            // 触摸结束事件
            handleTouchEnd(e) {
                e.preventDefault();
                this.lastTouches = Array.from(e.touches);
            }

            // 滚轮事件（鼠标缩放）
            handleWheel(e) {
                e.preventDefault();

                // 获取鼠标在画布上的位置
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // 计算缩放比例
                const zoomIntensity = 0.1;
                const scaleChange = e.deltaY < 0 ? (1 + zoomIntensity) : (1 - zoomIntensity);
                const newScale = this.scale * scaleChange;

                // 限制缩放范围
                if (newScale > 0.5 && newScale < 5) {
                    this.scale = newScale;

                    // 调整平移以实现围绕鼠标位置缩放
                    this.translateX = mouseX - (mouseX - this.translateX) * scaleChange;
                    this.translateY = mouseY - (mouseY - this.translateY) * scaleChange;

                    this.updateDisplay();
                }
            }
        }

        class GeolocationService {
            constructor() {
                this.position = null;
            }

            getLocation() {
                return new Promise((resolve, reject) => {
                    if (navigator.geolocation) {
                        navigator.geolocation.getCurrentPosition(
                            position => {
                                this.parsePosition(position);
                                resolve(this.position);
                            },
                            error => {
                                const errorMessage = this.getErrorDescription(error);
                                reject(errorMessage);
                            }
                        );
                    } else {
                        const errorMessage = "Geolocation is not supported by this browser.";
                        reject(errorMessage);
                    }
                });
            }

            parsePosition(position) {
                const coords = position.coords;
                this.position = {
                    latitude: coords.latitude,
                    longitude: coords.longitude,
                    accuracy: coords.accuracy,
                    altitude: coords.altitude !== null ? coords.altitude : undefined,
                    altitudeAccuracy: coords.altitudeAccuracy !== null ? coords.altitudeAccuracy : undefined,
                    heading: !isNaN(coords.heading) ? coords.heading : undefined,
                    speed: !isNaN(coords.speed) ? coords.speed : undefined,
                    timestamp: new Date(position.timestamp).toLocaleString()
                };
            }

            getErrorDescription(error) {
                switch (error.code) {
                    case error.PERMISSION_DENIED:
                        return "User denied the request for Geolocation.";
                    case error.POSITION_UNAVAILABLE:
                        return "Location information is unavailable.";
                    case error.TIMEOUT:
                        return "The request to get user location timed out.";
                    case error.UNKNOWN_ERROR:
                        return "An unknown error occurred.";
                    default:
                        return "An unexpected error occurred.";
                }
            }
        }

        // 获取DOM元素
        const canvas = document.getElementById('mapCanvas');
        const locateBtn = document.getElementById('locateBtn');
        const clearFogBtn = document.getElementById('clearFogBtn'); // 添加对清除迷雾按钮的引用
        const statusText = document.getElementById('statusText');
        const coordinatesDisplay = document.getElementById('coordinatesDisplay');

        // 创建战争迷雾地图实例
        let warFogMap = new WarFogMap('mapCanvas');
        let watchId = null;

        // 处理位置更新
        function handlePositionUpdate(position) {
            // 获取真实的GPS坐标
            const latitude = position.coords.latitude;
            const longitude = position.coords.longitude;
            const accuracy = position.coords.accuracy || 10;

            // 将GPS坐标转换为画布坐标
            const canvasPos = warFogMap.gpsToCanvas(latitude, longitude);
            let newX = canvasPos.x;
            let newY = canvasPos.y;

            // 确保坐标在画布范围内
            newX = Math.min(canvas.width - 5, Math.max(5, newX));
            newY = Math.min(canvas.height - 5, Math.max(5, newY));

            // 设置新位置并更新显示
            warFogMap.setUserPosition(newX, newY);

            // warFogMap.updateDisplay();
            warFogMap.centerOnUser();

            statusText.textContent = `位置已更新 - 精度: ${Math.round(accuracy)} m - ${latitude.toFixed(6)}, ${longitude.toFixed(6)} `;
        }

        // 获取用户位置
        function getUserLocation() {
            statusText.textContent = '正在获取位置...';

            // 使用 GeolocationService 类
            const geolocationService = new GeolocationService();

            geolocationService.getLocation()
                .then(location => {
                    console.log("Location data:", location);
                    statusText.textContent = '位置获取成功！等待位置更新...';

                    // 创建模拟位置对象以兼容现有代码
                    const mockPosition = {
                        coords: {
                            latitude: location.latitude,
                            longitude: location.longitude,
                            accuracy: location.accuracy
                        },
                        timestamp: Date.now()
                    };

                    handlePositionUpdate(mockPosition);
                })
                .catch(error => {
                    console.error("Error:", error);
                    statusText.textContent = `获取位置失败: ${error}。`;
                });
        }

        // 修改: 添加持续位置跟踪功能
        function startWatchingLocation() {
            if (watchId !== null) {
                stopWatching();
            }

            statusText.textContent = '正在获取位置...';

            // 使用 watchPosition 持续监听位置变化
            watchId = navigator.geolocation.watchPosition(
                position => {
                    statusText.textContent = '位置获取成功！持续跟踪中...';
                    handlePositionUpdate(position);
                },
                error => {
                    const errorMessage = new GeolocationService().getErrorDescription(error);
                    console.error("Error:", errorMessage);
                    statusText.textContent = `获取位置失败: ${errorMessage}。`;
                },
                {
                    enableHighAccuracy: true, // 启用高精度
                    maximumAge: 5000,         // 最长可接受的位置缓存时间(毫秒)
                    timeout: 10000            // 超时时间(毫秒)
                }
            );
        }

        // 停止位置监听
        function stopWatching() {
            if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
        }

        // 重置地图
        function resetMap() {
            stopWatching();

            // 重新初始化迷雾
            warFogMap = new WarFogMap('mapCanvas');

            // 重绘界面
            warFogMap.updateDisplay();
        }

        // // 添加鼠标移动事件监听器
        // canvas.addEventListener('mousemove', function (event) {
        //     const rect = canvas.getBoundingClientRect();
        //     const x = event.clientX - rect.left;
        //     const y = event.clientY - rect.top;

        //     // 将画布坐标转换为GPS坐标
        //     const gpsCoords = warFogMap.canvasToGps(x, y);

        //     // 显示坐标信息
        //     coordinatesDisplay.textContent = `经纬度: ${gpsCoords.lat.toFixed(6)}, ${gpsCoords.lng.toFixed(6)}`;
        // });

        // // 添加鼠标离开事件监听器
        // canvas.addEventListener('mouseleave', function () {
        //     coordinatesDisplay.textContent = '';
        // });

        // 修改: 添加处理hash变化的函数
        function handleHashChange() {
            const hash = window.location.hash.substring(1); // 移除#符号
            if (hash) {
                // 查找匹配的建筑
                const buildingIndex = Buildings.findIndex(building => building.id === hash);
                if (buildingIndex !== -1) {
                    // 更新建筑状态
                    Buildings[buildingIndex].status = 1;
                    // 保存到本地存储
                    localStorage.setItem('buildings_status', JSON.stringify(Buildings));
                    // 重新渲染底部面板
                    setGrid(2, Math.round(Buildings.length / 2), Buildings);
                }
            }
        }

        // 初始化
        function init() {
            // // 绑定重新定位按钮事件
            // locateBtn.addEventListener('click', () => {
            //     resetMap();
            //     getUserLocation();
            // });

            // // 绑定清除迷雾按钮事件
            // clearFogBtn.addEventListener('click', () => {
            //     warFogMap.clearFog(); // 调用清除迷雾的方法
            // });

            // 修改: 添加hash变化监听
            window.addEventListener('hashchange', handleHashChange);

            // 页面加载时检查当前hash
            // 修改: 从本地存储加载已保存的打卡状态
            const savedBuildings = localStorage.getItem('buildings_status');
            if (savedBuildings) {
                const parsedBuildings = JSON.parse(savedBuildings);
                // 更新Buildings数组中的status值
                for (let i = 0; i < parsedBuildings.length; i++) {
                    if (Buildings[i] && parsedBuildings[i]) {
                        Buildings[i].status = parsedBuildings[i].status;
                    }
                }
            }
            setGrid(2, Math.round(Buildings.length / 2), Buildings);
            handleHashChange();

            // 获取初始位置并开始持续跟踪
            // 修改: 使用 startWatchingLocation 替代 getUserLocation 来持续获取位置
            startWatchingLocation();
            // 将用户位置居中
            warFogMap.centerOnUser();
            window.scrollTo(0, document.body.scrollHeight);


        }

        // 页面加载完成后初始化
        window.onload = init;
    </script>
</body>

</html>